\documentclass[a4paper,10pt]{article}
\usepackage[paperwidth=210mm, paperheight=297mm, left=2.5cm, top=2.5cm, right=2.5cm, bottom=1.0cm, head=1.5cm, includefoot]{geometry}
%\usepackage[latin1]{inputenc}

\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}

\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\usepackage{bookman}
\usepackage{booktabs}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage{pdfpages}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{fixltx2e}
\usepackage{listings}

%\usepackage[T1]{fontenc}
%\usepackage{comment}
%\usepackage{makeidx}
%\usepackage{float}
%\usepackage{slashbox}

\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}



%%%%%%%%%  Datos  %%%%%%%%%

\title{ \textbf{Trabajo práctico 1: Conjunto de instrucciones MIPS} }

\author{Contini, Agustín - \textit{Padrón 89180}			\\
            \texttt{ agscontini@gmail.com }				\\
            Farina, Federico - \textit{Padrón 90177}			\\
            \texttt{ federicojosefarina@gmail.com }				\\
            Prystupiuk, Maximiliano  - \textit{Padrón 94853  }			\\
            \texttt{ mprystupiuk@gmail.com  }					\\[2.5ex]
            1er. Cuatrimestre de 2017					\\[1.0ex]
            \normalsize{66.20 Organización de Computadoras}		\\
            \normalsize{Facultad de Ingeniería, Universidad de Buenos Aires}	\\
	}
\date{\today}

%%%%%%%%%  Fin datos  %%%%%%%%%



\begin{document}



%%%%%%%%%  1era hoja: caratula y datos  %%%%%%%%%

\maketitle
\bigskip
\thispagestyle{empty}	% quita el numero en la primera pagina

\begin{abstract}
El trabajo consiste conseguir que un conjunto de programas
cumplan con una condición, cuando normalmente no lo harían, aprovechando las vulnerabilidades del stack y de la función gets() teniendo un buffer de largo fijo y conocido.
Para este cometido se utilizará gdb y objdump como herramientas sobre MIPS32 en un entorno NetBSD.

\end{abstract}



%%%%%%%%%  Fin 1era hoja  %%%%%%%%%



%%%%%%%%%  Head y foot  %%%%%%%%%

\pagestyle{fancy}
\lhead{\includegraphics[width=1.2cm]{./img/logo.png}}
\chead{Trabajo práctico 1: Conjunto de instrucciones MIPS \\ \textit{Contini  -  Farina  -  Prystupiuk} }

\rfoot{$1^{er}$ Cuatrimestre 2017}
\lfoot{66.20 Organizaci\'on de Computadoras}
\cfoot{\hspace{2.4cm}   P\'agina \thepage \, de \pageref{LastPage} }

%%%%%%%%%  Fin head y foot  %%%%%%%%%



\normalsize

\newpage
\tableofcontents	% hoja de indices de titulos, subtitulos

\vspace{2.0cm}
\listoffigures		% hoja de indices de figuras

\newpage
\section{Introducci\'on}

\subsection{Problemas de programación insegura}

Los ejercicios a analizar fueron diseñados especialmente para la compresión del funcionamiento de los programas compilados en C por Gerardo Richarte y son de especial interés para la compresión del stack y la explotación de sus vulnerabilidades.
\par El trabajo consiste en conseguir que los programas stack1.c a stack5.c cumplan una condición y impriman la frase "you win!" aprovechando que utilizan la función gets para llenar un buffer de largo fijo y conocido utilizando gdb para examinar el stack y los valores de los registros y objdump para inspeccionar de manera sencilla las posiciones relativas al stack pointer.


\newpage
\section{Uso}
\subsection{Compilado}
Dentro del entorno de NetBSD, en el directorio del proyecto ejecutar para cada archivo i:

\begin{verbatim}
$ gcc -g stack{i}.c -o stack{i}.o
\end{verbatim}

\subsection{Herramientas utilizadas}
\subsubsection{GDB}

GDB (Gnu Project Debugger) es una herramienta que permite entre otras cosas, correr el programa con la posibilidad de detenerlo cuando se cumple cierta condición, avanzar paso a paso y, entre otras cosas, analizar el stack frame actual de cada uno de ellos.


\subsubsection{Objdump}

Objdump es una herramienta muy util que despliega información sobre uno o más archivos objecto de manera que os permite ver el codigo assembler en ellos.

\newpage
\section{Programas}
\subsection{stack1}
\lstset{ language = C, numbers=left, tabsize=4, breaklines=true, frame=single }
\lstinputlisting{./stack1.c}

\subsubsection{Descripción}

\bigskip
Mediante gdb podemos ver que la disposición del stack frame para este programa es el siguiente

\bigskip

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.7]{./recursos/stack1.png}
	\caption{Gr\'afico del stack del programa stack1}
    \label{fig:stack1}
\end{figure}


\bigskip
Lo que nos dice que las posiciones del array del buffer siguen la disposición:

\begin{equation*}
\forall x \in [0,n], \quad \&buff[x]=sp(24+ 4 * \floor*{\frac{x}{4}})
\end{equation*}


\subsubsection{Solución}

Al crecer las posiciones del array hacia arriba en el stack lo único que debemos hacer es escribir el buffer en la posición x=80  para que la última word coincida con la posición de memoria de cookie, en la posición 104(sp), y luego hacer que corresponda con el hexadecimal 0x41424344 que es el codigo ascci correspondiente al texto ABCD.
\bigskip
Una manera de comprobar esto es ejecutar las siguientes lineas en una consola:

\begin{lstlisting}
input = 0000000000000000000000000000000000000000
0000000000000000000000000000000000000000DCBA
echo $input | ./stack1.o
\end{lstlisting}

O escapeando y en hexadecimal:

\begin{lstlisting}
input = 0000000000000000000000000000000000000000
0000000000000000000000000000000000000000\x44\x43\x42\x41
echo -e $input | ./stack1.o
\end{lstlisting}

\bigskip

Lo que en ambos casos resultará en el output: "you win!"


\subsection{stack2}
\lstset{ language = C, numbers=left, tabsize=4, breaklines=true, frame=single }
\lstinputlisting{./stack2.c}

\subsubsection{Descripción}

El stack será el mismo que el de la figura \textbf{(\ref{fig:stack1})}. La diferencia en este programa es que no inicializamos con un valor a cookie, pero al tener que sobreeescribirlo nos es indistinto.

\subsubsection{Solución}

En este caso el hexadecimal que queremos que esté en la posición sp(104) es el 0x01020305, por lo tanto una posible solución es:

\begin{lstlisting}
input = 0000000000000000000000000000000000000000
0000000000000000000000000000000000000000\x05\x03\x02\x01
echo $input | ./stack2.o
\end{lstlisting}
\bigskip

Lo que resultará en el output: "you win!"

\subsection{stack3}
\lstset{ language = C, numbers=left, tabsize=4, breaklines=true, frame=single }
\lstinputlisting{./stack3.c}

\subsubsection{Descripción}
Al igual que en los casos anteriores, el stack será el mismo que el de la figura \textbf{(\ref{fig:stack1})}.
\subsubsection{Solución}

El hexadecimal a escribir en esta caso es 0x01020005, de manera que una posible solución será:

\begin{lstlisting}
input = 0000000000000000000000000000000000000000
0000000000000000000000000000000000000000\x05\x00\x02\x01
echo $input | ./stack3.o
\end{lstlisting}

\bigskip

Lo que resultará en el output: "you win!"

\subsection{stack4}
\lstset{ language = C, numbers=left, tabsize=4, breaklines=true, frame=single }
\lstinputlisting{./stack4.c}

\subsection{stack5}

\lstset{ language = C, numbers=left, tabsize=4, breaklines=true, frame=single }
\lstinputlisting{./stack5.c}

\lstset{ language = C, numbers=left, tabsize=4, breaklines=true, frame=single }
\lstinputlisting{./stack5.h}

\lstset{ language = C, numbers=left, tabsize=4, breaklines=true, frame=single }
\lstinputlisting{./win.h}

\lstset{ language = C, numbers=left, tabsize=4, breaklines=true, frame=single }
\lstinputlisting{./win.c}

\section{Conclusión}









\end{document}
